{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<!-- ---\n",
        "title: \"User Guide\"\n",
        "sidebar: python\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "\n",
        "---\n",
        "\n",
        "# py-distance-transforms User Guide\n",
        "\n",
        "This guide covers both basic and advanced usage of the py-distance-transforms library.\n",
        "\n",
        "## Getting Started\n",
        "\n",
        "### Installation\n",
        "\n",
        "```bash\n",
        "pip install py_distance_transforms\n",
        "```\n",
        "\n",
        "For GPU support, make sure you have PyTorch with CUDA installed:\n",
        "\n",
        "```bash\n",
        "pip install torch --extra-index-url https://download.pytorch.org/whl/cu118\n",
        "```\n",
        "\n",
        "### Basic Usage\n",
        "\n",
        "The primary function in py_distance_transforms is `transform`. This function takes a binary array (with 0s and 1s) and calculates the squared Euclidean distance from each 0 pixel to the nearest 1 pixel.\n"
      ],
      "id": "a0a8efff"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from py_distance_transforms import transform\n",
        "\n",
        "# Create a random binary array\n",
        "arr = np.random.choice([0, 1], size=(10, 10)).astype(np.float32)\n",
        "\n",
        "# Apply distance transform\n",
        "result = transform(arr)\n",
        "\n",
        "# Visualize\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))\n",
        "ax1.imshow(arr, cmap='gray')\n",
        "ax1.set_title('Original')\n",
        "ax2.imshow(result, cmap='gray')\n",
        "ax2.set_title('Distance Transform')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "0382e3f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Real-World Example\n",
        "\n",
        "Let's load an image and apply a distance transform:\n"
      ],
      "id": "399c30e5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from py_distance_transforms import transform\n",
        "from skimage import io, color, filters\n",
        "\n",
        "# Download and load image\n",
        "import urllib.request\n",
        "url = \"http://docs.opencv.org/3.1.0/water_coins.jpg\"\n",
        "urllib.request.urlretrieve(url, \"coins.jpg\")\n",
        "img = io.imread(\"coins.jpg\")\n",
        "\n",
        "# Convert to grayscale and threshold\n",
        "img_gray = color.rgb2gray(img)\n",
        "img_binary = img_gray > filters.threshold_otsu(img_gray)\n",
        "\n",
        "# Apply distance transform\n",
        "img_dist = transform(img_binary.astype(np.float32))\n",
        "\n",
        "# Visualize\n",
        "fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n",
        "axes[0].imshow(img)\n",
        "axes[0].set_title('Original Image')\n",
        "axes[1].imshow(img_binary, cmap='gray')\n",
        "axes[1].set_title('Binary Image')\n",
        "axes[2].imshow(img_dist, cmap='viridis')\n",
        "axes[2].set_title('Distance Transform')\n",
        "for ax in axes:\n",
        "    ax.axis('off')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "c3a5ce2f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Understanding Euclidean Distance\n",
        "\n",
        "By default, `transform` returns the squared Euclidean distance. For the true Euclidean distance, take the square root:\n"
      ],
      "id": "031b037b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from py_distance_transforms import transform\n",
        "\n",
        "# Create a simple array\n",
        "arr = np.array([\n",
        "    [0, 1, 1, 0, 1],\n",
        "    [0, 0, 0, 1, 0],\n",
        "    [1, 1, 0, 0, 0]\n",
        "], dtype=np.float32)\n",
        "\n",
        "# Apply squared Euclidean distance transform\n",
        "sq_dist = transform(arr)\n",
        "\n",
        "# Calculate true Euclidean distance\n",
        "euc_dist = np.sqrt(sq_dist)\n",
        "\n",
        "print(\"Original array:\")\n",
        "print(arr)\n",
        "print(\"\\nSquared Euclidean distance:\")\n",
        "print(sq_dist)\n",
        "print(\"\\nEuclidean distance:\")\n",
        "print(euc_dist)"
      ],
      "id": "41b730f5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Comparison with SciPy\n",
        "\n",
        "Let's compare with SciPy's implementation:\n"
      ],
      "id": "845f5b98"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from py_distance_transforms import transform\n",
        "from scipy.ndimage import distance_transform_edt\n",
        "import time\n",
        "\n",
        "# Create a larger random binary array\n",
        "size = 100\n",
        "arr = np.random.choice([0, 1], size=(size, size)).astype(np.float32)\n",
        "\n",
        "# Time SciPy implementation\n",
        "start = time.time()\n",
        "scipy_result = distance_transform_edt(arr)**2  # Square to match our output\n",
        "scipy_time = time.time() - start\n",
        "\n",
        "# Time our implementation\n",
        "start = time.time()\n",
        "our_result = transform(arr)\n",
        "our_time = time.time() - start\n",
        "\n",
        "# Calculate difference\n",
        "diff = np.abs(scipy_result - our_result)\n",
        "\n",
        "print(f\"SciPy time: {scipy_time:.6f} seconds\")\n",
        "print(f\"Our time: {our_time:.6f} seconds\")\n",
        "print(f\"Speedup: {scipy_time/our_time:.2f}x\")\n",
        "print(f\"Max difference: {np.max(diff):.8f}\")\n",
        "\n",
        "# Visualize results\n",
        "fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n",
        "axes[0].imshow(scipy_result, cmap='viridis')\n",
        "axes[0].set_title('SciPy Result')\n",
        "axes[1].imshow(our_result, cmap='viridis')\n",
        "axes[1].set_title('Our Result')\n",
        "axes[2].imshow(diff, cmap='hot')\n",
        "axes[2].set_title('Difference')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "63945706",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Advanced Features\n",
        "\n",
        "### GPU Acceleration\n",
        "\n",
        "py_distance_transforms supports GPU acceleration for NVIDIA GPUs using PyTorch tensors.\n"
      ],
      "id": "bc5f9105"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import torch\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import time\n",
        "from py_distance_transforms import transform_cuda\n",
        "\n",
        "# Check if CUDA is available\n",
        "if torch.cuda.is_available():\n",
        "    # Create a random binary tensor on GPU\n",
        "    size = 1000\n",
        "    x_gpu = torch.rand((size, size), device='cuda')\n",
        "    x_gpu = (x_gpu > 0.5).float()\n",
        "    \n",
        "    # Measure time for GPU computation\n",
        "    start = time.time()\n",
        "    result_gpu = transform_cuda(x_gpu)\n",
        "    gpu_time = time.time() - start\n",
        "    \n",
        "    # Transfer to CPU for comparison\n",
        "    x_cpu = x_gpu.cpu().numpy()\n",
        "    \n",
        "    # Measure time for CPU computation\n",
        "    start = time.time()\n",
        "    result_cpu = transform(x_cpu)\n",
        "    cpu_time = time.time() - start\n",
        "    \n",
        "    print(f\"CPU time: {cpu_time:.6f} seconds\")\n",
        "    print(f\"GPU time: {gpu_time:.6f} seconds\")\n",
        "    print(f\"Speedup: {cpu_time/gpu_time:.2f}x\")\n",
        "    \n",
        "    # Compare results\n",
        "    result_from_gpu = result_gpu.cpu().numpy()\n",
        "    diff = np.abs(result_cpu - result_from_gpu)\n",
        "    print(f\"Max difference: {np.max(diff):.8f}\")\n",
        "else:\n",
        "    print(\"CUDA is not available. GPU examples cannot be run.\")"
      ],
      "id": "04a9e3a4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Working with 3D Data\n",
        "\n",
        "py_distance_transforms supports 3D arrays as well:\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from py_distance_transforms import transform\n",
        "from mpl_toolkits.mplot3d import Axes3D\n",
        "\n",
        "# Create a 3D binary array\n",
        "size = 20\n",
        "arr_3d = np.zeros((size, size, size), dtype=np.float32)\n",
        "# Add a few 1s\n",
        "arr_3d[5, 5, 5] = 1\n",
        "arr_3d[15, 15, 15] = 1\n",
        "arr_3d[5, 15, 10] = 1\n",
        "\n",
        "# Apply distance transform\n",
        "result_3d = transform(arr_3d)\n",
        "\n",
        "# Visualize a slice\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))\n",
        "slice_idx = size // 2\n",
        "ax1.imshow(arr_3 -->"
      ],
      "id": "fe606638"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/daleblack/Library/Python/3.9/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}