{
  "hash": "ea6c41a4daeef4871737aa3d01c8cf86",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"User Guide\"\nsidebar: julia\nformat:\n  html:\n    toc: true\nexecute:\n  engine: julia\n  julia:\n    threads: 4\n---\n\n\n\n\nThis guide covers both basic and advanced usage of DistanceTransforms.jl.\n\n## Getting Started\n\n### Installation\n\n```julia\nusing Pkg\nPkg.add(\"DistanceTransforms\")\n```\n\n### Basic Usage\n\nThe primary function in DistanceTransforms.jl is `transform`. This function processes an array of 0s and 1s, converting each background element (0) into a value representing its squared Euclidean distance to the nearest foreground element (1).\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing DistanceTransforms: transform, boolean_indicator\nusing CairoMakie: Figure, Axis, heatmap!, hidedecorations!\n\n# Create a random binary array\narr = rand([0, 1], 10, 10)\n\n# Apply distance transform\ntransformed = transform(boolean_indicator(arr))\n\n# Create visualization\nfig = Figure(size = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Original\")\nax2 = Axis(fig[1, 2], title = \"Distance Transform\")\nheatmap!(ax1, arr, colormap = :grays)\nheatmap!(ax2, transformed, colormap = :grays)\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](guide_files/figure-html/cell-2-output-1.svg){}\n:::\n:::\n\n\n\n\n\n\n### Real-World Example\n\nLet's apply a distance transform to a real image:\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Images\n\n# Download and load example image\nimg = load(download(\"http://docs.opencv.org/3.1.0/water_coins.jpg\"))\n\n# Convert to binary image\nimg_bw = Gray.(img) .> 0.5\n\n# Apply distance transform\nimg_tfm = transform(boolean_indicator(img_bw))\n\n# Visualize\nfig = Figure(size = (900, 300))\nax1 = Axis(fig[1, 1], title = \"Original Image\")\nax2 = Axis(fig[1, 2], title = \"Segmented Image\")\nax3 = Axis(fig[1, 3], title = \"Distance Transform\")\nheatmap!(ax1, rotr90(img), colormap = :grays)\nheatmap!(ax2, rotr90(img_bw), colormap = :grays)\nheatmap!(ax3, rotr90(img_tfm), colormap = :grays)\nhidedecorations!.([ax1, ax2, ax3])\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](guide_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n\n\n\n\n### Understanding Euclidean Distance\n\nThe library, by default, returns the squared Euclidean distance. If you need the true Euclidean distance, you can take the square root of each element:\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# Create sample binary array\narray2 = [\n    0 1 1 0 1\n    0 0 0 1 0\n    1 1 0 0 0\n]\n\n# Convert to boolean indicator\narray2_bool = boolean_indicator(array2)\n\n# Apply squared Euclidean distance transform\nsq_euc_transform = transform(array2_bool)\n\n# Convert to true Euclidean distance\neuc_transform = sqrt.(sq_euc_transform)\n\n# Display results\nprintln(\"Squared Euclidean Distance:\")\ndisplay(sq_euc_transform)\nprintln(\"\\nEuclidean Distance:\")\ndisplay(euc_transform)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSquared Euclidean Distance:\n\nEuclidean Distance:\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n3×5 Matrix{Float32}:\n 1.0  0.0  0.0  1.0  0.0\n 1.0  1.0  1.0  0.0  1.0\n 0.0  0.0  1.0  1.0  2.0\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n3×5 Matrix{Float32}:\n 1.0  0.0  0.0  1.0  0.0\n 1.0  1.0  1.0  0.0  1.0\n 0.0  0.0  1.0  1.0  1.41421\n```\n:::\n:::\n\n\n\n\n\n\n### Comparison with ImageMorphology.jl\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nusing ImageMorphology: distance_transform, feature_transform\n\n# Apply ImageMorphology distance transform\neuc_transform2 = distance_transform(feature_transform(Bool.(array2)))\n\n# Compare results\nprintln(\"ImageMorphology result:\")\ndisplay(euc_transform2)\nprintln(\"\\nAre the results approximately equal?\")\nisapprox(euc_transform2, euc_transform; rtol = 1e-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImageMorphology result:\n\nAre the results approximately equal?\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n3×5 Matrix{Float64}:\n 1.0  0.0  0.0  1.0  0.0\n 1.0  1.0  1.0  0.0  1.0\n 0.0  0.0  1.0  1.0  1.41421\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n\n\n\n## Advanced Features\n\n### Multi-threading\n\nDistanceTransforms.jl efficiently utilizes multi-threading, particularly in its Felzenszwalb distance transform algorithm.\n\n⚠️ Julia might only load with `1 thread` which makes the actual benchmark below meaningless and potentially confusing. Use this for understanding how to use the `threaded` kwarg\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nusing BenchmarkTools\nusing Base.Threads: nthreads\n\n# Create a random binary array\nx = boolean_indicator(rand([0, 1], 1000, 1000))\n\n# Single-threaded benchmark\nsingle_threaded = @benchmark transform($x; threaded = false)\n\n# Multi-threaded benchmark\nmulti_threaded = @benchmark transform($x; threaded = true)\n\n# Display results\nprintln(\"Number of threads: $(nthreads())\")\nprintln(\"Single-threaded minimum time: $(minimum(single_threaded).time / 1e6) ms\")\nprintln(\"Multi-threaded minimum time: $(minimum(multi_threaded).time / 1e6) ms\")\nprintln(\"Speedup factor: $(minimum(single_threaded).time / minimum(multi_threaded).time)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of threads: 1\nSingle-threaded minimum time: 17.071291 ms\nMulti-threaded minimum time: 17.319625 ms\nSpeedup factor: 0.9856616987954416\n```\n:::\n:::\n\n\n\n\n\n\n### GPU Acceleration\n\nDistanceTransforms.jl extends its performance capabilities with GPU acceleration. The library uses Julia's multiple dispatch to automatically leverage GPU resources when available.\n\n#### CUDA Example\n\n```julia\nusing CUDA\nusing DistanceTransforms\n\n# Create a random array on GPU\nx_gpu = CUDA.rand([0, 1], 1000, 1000)\nx_gpu = boolean_indicator(x_gpu)\n\n# The transform function automatically uses GPU\nresult_gpu = transform(x_gpu)\n\n# Transfer result back to CPU if needed\nresult_cpu = Array(result_gpu)\n```\n\n#### Metal Example\n\n```julia\nusing Metal\nusing DistanceTransforms\n\n# Create a random array on GPU\nx_gpu = Metal.rand([0, 1], 1000, 1000)\nx_gpu = boolean_indicator(x_gpu)\n\n# The transform function automatically uses GPU\nresult_gpu = transform(x_gpu)\n\n# Transfer result back to CPU if needed\nresult_cpu = Array(result_gpu)\n```\n\n### Performance Benchmarks\n\nPerformance comparison across different implementations for 2D and 3D distance transforms:\n\n![Performance Comparison](../images/julia_distance_transforms.png)\n\nAs shown in the graph, the GPU implementation demonstrates superior performance, especially for larger arrays.\n\n### Best Practices\n\n1. **For small arrays (<100x100)**: CPU with multi-threading is often sufficient\n2. **For medium arrays**: Multi-threaded CPU may be faster than GPU due to lower overhead\n3. **For large arrays (>1000x1000)**: GPU acceleration provides the best performance\n4. **For 3D data**: GPU acceleration is strongly recommended due to the computational complexity\n\n## Algorithm Details\n\nOn the CPU, DistanceTransforms.jl uses the squared Euclidean distance transform algorithm by [Felzenszwalb and Huttenlocher](https://theoryofcomputing.org/articles/v008a019/), known for its accuracy and efficiency. On the GPU, thanks to the amazing [AcceleratedKernels.jl](https://github.com/JuliaGPU/AcceleratedKernels.jl) and [KernelAbstraction.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) packages, the algorithm is essentially identical.\n\n",
    "supporting": [
      "guide_files"
    ],
    "filters": [],
    "includes": {}
  }
}