{
  "hash": "8b0c201ec5ef58c91f171d8fb53a6497",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"API Reference\"\nsidebar: julia\nformat:\n  html:\n    toc: true\n    cold-fold: true\nexecute:\n  engine: julia\n---\n\n\n\n\nThis page documents all the exported functions and types in DistanceTransforms.jl.\n\n\n\n\n::: {#2 .cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\n## `boolean_indicator`\n\n```julia\nboolean_indicator(f::AbstractArray)\nboolean_indicator(f::AbstractGPUArray)\nboolean_indicator(f::BitArray)\n```\n\nCreate a float representation of a boolean indicator array where `0` represents the background and `1` represents the foreground. This function converts a logical array into a floating-point array where foreground values (logical `1`) are marked as `0.0f0` (float representation of `0`), and background values (logical `0`) are marked with a large float number `1.0f10`. This representation is useful in distance transform operations to differentiate between the foreground and the background.\n\n#### Arguments\n\n  * `f`: An array of boolean values or an `AbstractGPUArray` of boolean values, where `true` indicates the foreground and `false` indicates the background.\n\n#### Returns\n\n  * A floating-point array of the same dimensions as `f`, with foreground values set to `0.0f0` and background values set to `1.0f10`.\n\n#### Performance\n\n  * If `f` is a `BitArray`, the conversion uses LoopVectorization.jl for a potential speedup. The warning check arguments are disabled for performance reasons.\n  * If `f` is an `AbstractGPUArray`, the computation is offloaded to the GPU using a custom kernel, `boolean_indicator_kernel`, which is expected to yield a significant speedup on compatible hardware.\n\n#### Examples\n\n```julia\nf = BitArray([true, false, true, false])\nf_float = boolean_indicator(f)\n# f_float will be Float32[0.0f0, 1.0f10, 0.0f0, 1.0f10]\n\nf_gpu = CUDA.zeros(Bool, 10) # assuming CUDA.jl is used for GPU arrays\nf_gpu[5] = true\nf_float_gpu = boolean_indicator(f_gpu)\n# f_float_gpu will be a GPU array with the fifth element as 0.0f0 and others as 1.0f10\n```\n\n#### Notes\n\n  * The choice of `1.0f10` as the large number is arbitrary and can be adjusted if needed for specific applications.\n  * When `f` is an `AbstractGPUArray`, the `boolean_indicator_kernel` kernel function is used to perform the operation in parallel on the GPU.\n  * The `KernelAbstractions.synchronize(backend)` call ensures that all GPU operations are completed before returning the result.\n\n\n---\n\n## `transform`\n\n```julia\ntransform(f::AbstractVector)\ntransform(img::AbstractMatrix; threaded=true)\ntransform(vol::AbstractArray{<:Real,3}; threaded=true)\ntransform(img::AbstractGPUMatrix)\n```\n\nNon-in-place squared Euclidean distance transforms that return a new array with the result. They allocate necessary intermediate arrays internally.\n\n  * The first function operates on vectors.\n  * The second function operates on matrices with optional threading.\n  * The third function operates on 3D arrays with optional threading.\n  * The fourth function is specialized for GPU matrices.\n\nThe `threaded` parameter can be used to enable or disable parallel computation on the CPU.\n\n#### Arguments\n\n  * `f/img/vol`: Input vector, matrix, or 3D array to be transformed.\n\n#### Examples\n\n```julia\nf = rand([0f0, 1f0], 10)\nf_bool = boolean_indicator(f)\nf_tfm = transform(f_bool)\n```\n\n\n---\n\n## `transform!`\n\n```julia\ntransform!(f::AbstractVector, output, v, z)\ntransform!(img::AbstractMatrix, output, v, z; threaded=true)\ntransform!(vol::AbstractArray{<:Real,3}, output, v, z, temp; threaded=true)\ntransform!(img::AbstractGPUMatrix, output, v, z)\n```\n\nIn-place squared Euclidean distance transforms. These functions apply the transform to the input data and store the result in the `output` argument.\n\n  * The first function operates on vectors.\n  * The second function operates on matrices with optional threading.\n  * The third function operates on 3D arrays with optional threading.\n  * The fourth function is specialized for GPU matrices.\n\nThe intermediate arrays `v` and `z` (and `temp` for 3D arrays) are used for computation. The `threaded` parameter enables parallel computation on the CPU.\n\n#### Arguments\n\n  * `f`: Input vector, matrix, or 3D array.\n  * `output`: Preallocated array to store the result.\n  * `v`: Preallocated array for indices, matching the dimensions of `f`.\n  * `z`: Preallocated array for intermediate values, one element larger than `f`.\n  * `temp`: Preallocated array for intermediate values when transforming 3D arrays, matching the dimensions of `output`.\n\n#### Examples\n\n```julia\nf = rand([0f0, 1f0], 10)\nf_bool = boolean_indicator(f)\noutput = similar(f)\nv = ones(Int32, size(f))\nz = ones(eltype(f), size(f) .+ 1)\ntransform!(f_bool, output, v, z)\n```\n\n\n---\n\n\n```\n:::\n:::\n\n\n",
    "supporting": [
      "api_files"
    ],
    "filters": [],
    "includes": {}
  }
}