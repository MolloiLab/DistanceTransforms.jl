[
  {
    "objectID": "julia/api.html",
    "href": "julia/api.html",
    "title": "API Reference",
    "section": "",
    "text": "This page documents all the exported functions and types in DistanceTransforms.jl.\n## `boolean_indicator`\n\n```julia\nboolean_indicator(f::AbstractArray)\nboolean_indicator(f::AbstractGPUArray)\nboolean_indicator(f::BitArray)\nCreate a float representation of a boolean indicator array where 0 represents the background and 1 represents the foreground. This function converts a logical array into a floating-point array where foreground values (logical 1) are marked as 0.0f0 (float representation of 0), and background values (logical 0) are marked with a large float number 1.0f10. This representation is useful in distance transform operations to differentiate between the foreground and the background.\n\nArguments\n\nf: An array of boolean values or an AbstractGPUArray of boolean values, where true indicates the foreground and false indicates the background.\n\n\n\nReturns\n\nA floating-point array of the same dimensions as f, with foreground values set to 0.0f0 and background values set to 1.0f10.\n\n\n\nPerformance\n\nIf f is a BitArray, the conversion uses LoopVectorization.jl for a potential speedup. The warning check arguments are disabled for performance reasons.\nIf f is an AbstractGPUArray, the computation is offloaded to the GPU using a custom kernel, boolean_indicator_kernel, which is expected to yield a significant speedup on compatible hardware.\n\n\n\nExamples\nf = BitArray([true, false, true, false])\nf_float = boolean_indicator(f)\n# f_float will be Float32[0.0f0, 1.0f10, 0.0f0, 1.0f10]\n\nf_gpu = CUDA.zeros(Bool, 10) # assuming CUDA.jl is used for GPU arrays\nf_gpu[5] = true\nf_float_gpu = boolean_indicator(f_gpu)\n# f_float_gpu will be a GPU array with the fifth element as 0.0f0 and others as 1.0f10\n\n\nNotes\n\nThe choice of 1.0f10 as the large number is arbitrary and can be adjusted if needed for specific applications.\nWhen f is an AbstractGPUArray, the boolean_indicator_kernel kernel function is used to perform the operation in parallel on the GPU.\nThe KernelAbstractions.synchronize(backend) call ensures that all GPU operations are completed before returning the result.\n\n\n\n\ntransform\ntransform(f::AbstractVector)\ntransform(img::AbstractMatrix; threaded=true)\ntransform(vol::AbstractArray{&lt;:Real,3}; threaded=true)\ntransform(img::AbstractGPUMatrix)\nNon-in-place squared Euclidean distance transforms that return a new array with the result. They allocate necessary intermediate arrays internally.\n\nThe first function operates on vectors.\nThe second function operates on matrices with optional threading.\nThe third function operates on 3D arrays with optional threading.\nThe fourth function is specialized for GPU matrices.\n\nThe threaded parameter can be used to enable or disable parallel computation on the CPU.\n\nArguments\n\nf/img/vol: Input vector, matrix, or 3D array to be transformed.\n\n\n\nExamples\nf = rand([0f0, 1f0], 10)\nf_bool = boolean_indicator(f)\nf_tfm = transform(f_bool)\n\n\n\n\ntransform!\ntransform!(f::AbstractVector, output, v, z)\ntransform!(img::AbstractMatrix, output, v, z; threaded=true)\ntransform!(vol::AbstractArray{&lt;:Real,3}, output, v, z, temp; threaded=true)\ntransform!(img::AbstractGPUMatrix, output, v, z)\nIn-place squared Euclidean distance transforms. These functions apply the transform to the input data and store the result in the output argument.\n\nThe first function operates on vectors.\nThe second function operates on matrices with optional threading.\nThe third function operates on 3D arrays with optional threading.\nThe fourth function is specialized for GPU matrices.\n\nThe intermediate arrays v and z (and temp for 3D arrays) are used for computation. The threaded parameter enables parallel computation on the CPU.\n\nArguments\n\nf: Input vector, matrix, or 3D array.\noutput: Preallocated array to store the result.\nv: Preallocated array for indices, matching the dimensions of f.\nz: Preallocated array for intermediate values, one element larger than f.\ntemp: Preallocated array for intermediate values when transforming 3D arrays, matching the dimensions of output.\n\n\n\nExamples\nf = rand([0f0, 1f0], 10)\nf_bool = boolean_indicator(f)\noutput = similar(f)\nv = ones(Int32, size(f))\nz = ones(eltype(f), size(f) .+ 1)\ntransform!(f_bool, output, v, z)\n\n:::\n:::\n\n\n\n\n\n\n:::{#quarto-navigation-envelope .hidden}\n[Julia]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl\"}\n[Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXItdGl0bGU=\"}\n[User Guide]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1wcmV2\"}\n[Overview]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyOi9qdWxpYS9pbmRleC5odG1sT3ZlcnZpZXc=\"}\n[User Guide]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyOi9qdWxpYS9ndWlkZS5odG1sVXNlci1HdWlkZQ==\"}\n[API Reference]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyOi9qdWxpYS9hcGkuaHRtbEFQSS1SZWZlcmVuY2U=\"}\n[Home]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6SG9tZQ==\"}\n[/index.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2luZGV4Lmh0bWw=\"}\n[Julia]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6SnVsaWE=\"}\n[Overview]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6T3ZlcnZpZXc=\"}\n[/julia/index.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2p1bGlhL2luZGV4Lmh0bWw=\"}\n[User Guide]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6VXNlciBHdWlkZQ==\"}\n[/julia/guide.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2p1bGlhL2d1aWRlLmh0bWw=\"}\n[API Reference]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6QVBJIFJlZmVyZW5jZQ==\"}\n[/julia/api.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2p1bGlhL2FwaS5odG1s\"}\n[Python]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6UHl0aG9u\"}\n[/python/index.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3B5dGhvbi9pbmRleC5odG1s\"}\n[/python/guide.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3B5dGhvbi9ndWlkZS5odG1s\"}\n[/python/api.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3B5dGhvbi9hcGkuaHRtbA==\"}\n[About]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6QWJvdXQ=\"}\n[/about.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2Fib3V0Lmh0bWw=\"}\n[https://github.com/MolloiLab/DistanceTransforms.jl]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly9naXRodWIuY29tL01vbGxvaUxhYi9EaXN0YW5jZVRyYW5zZm9ybXMuamw=\"}\n[API Reference]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWJyZWFkY3J1bWJzLUFQSS1SZWZlcmVuY2U=\"}\n\n:::{.hidden .quarto-markdown-envelope-contents render-id=\"Zm9vdGVyLWxlZnQ=\"}\nCopyright 2024, Dale Black\n:::\n\n:::\n\n\n\n:::{#quarto-meta-markdown .hidden}\n[API Reference – Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW1ldGF0aXRsZQ==\"}\n[API Reference – Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=\"}\n[API Reference – Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW9nY2FyZHRpdGxl\"}\n[Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW1ldGFzaXRlbmFtZQ==\"}\n[Efficient distance transform operations for CPU and GPU in Julia and Python]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==\"}\n[Efficient distance transform operations for CPU and GPU in Julia and Python]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW9nY2FyZGRkZXNj\"}\n:::\n\n\n\n\n&lt;!-- --&gt;\n\n::: {.quarto-embedded-source-code}\n```````````````````{.markdown shortcodes=\"false\"}\n---\ntitle: \"API Reference\"\nsidebar: julia\nformat:\n  html:\n    toc: true\n    cold-fold: true\nexecute:\n  engine: julia\n---\n\nThis page documents all the exported functions and types in DistanceTransforms.jl.\n\nquarto-executable-code-5450563D\n\n```julia\n#| echo: false\n\n\nusing DistanceTransforms\nusing Markdown\n\n\"\"\"\n    generate_markdown_docs()\n    \nGenerate Markdown documentation for all exported functions in DistanceTransforms.jl,\nreturning a single string with properly formatted markdown.\n\"\"\"\nfunction generate_markdown_docs()\n    # Get all exported names from DistanceTransforms\n    all_names = names(DistanceTransforms)\n    exported_functions = filter(x -&gt; x != :DistanceTransforms, all_names)\n    \n    # Create a string buffer to collect all output\n    result = IOBuffer()\n    \n    # Generate documentation for each function\n    for name in exported_functions\n        \n        # Get the documentation and convert it to string\n        doc = getproperty(DistanceTransforms, name)\n        doc_string = string(Docs.doc(doc))\n        \n        # Write the documentation\n        write(result, doc_string)\n        write(result, \"\\n\\n---\\n\\n\")\n    end\n    \n    # Return the collected documentation as a string\n    return String(take!(result))\nend\n\n# Call the function to generate the documentation\ndocs = generate_markdown_docs()\n\nprintln(docs)\n```````````````````",
    "crumbs": [
      "Home",
      "API Reference"
    ]
  },
  {
    "objectID": "julia/api.html#transform",
    "href": "julia/api.html#transform",
    "title": "API Reference",
    "section": "transform",
    "text": "transform\ntransform(f::AbstractVector)\ntransform(img::AbstractMatrix; threaded=true)\ntransform(vol::AbstractArray{&lt;:Real,3}; threaded=true)\ntransform(img::AbstractGPUMatrix)\nNon-in-place squared Euclidean distance transforms that return a new array with the result. They allocate necessary intermediate arrays internally.\n\nThe first function operates on vectors.\nThe second function operates on matrices with optional threading.\nThe third function operates on 3D arrays with optional threading.\nThe fourth function is specialized for GPU matrices.\n\nThe threaded parameter can be used to enable or disable parallel computation on the CPU.\n\nArguments\n\nf/img/vol: Input vector, matrix, or 3D array to be transformed.\n\n\n\nExamples\nf = rand([0f0, 1f0], 10)\nf_bool = boolean_indicator(f)\nf_tfm = transform(f_bool)",
    "crumbs": [
      "Home",
      "API Reference"
    ]
  },
  {
    "objectID": "julia/api.html#transform-1",
    "href": "julia/api.html#transform-1",
    "title": "API Reference",
    "section": "transform!",
    "text": "transform!\ntransform!(f::AbstractVector, output, v, z)\ntransform!(img::AbstractMatrix, output, v, z; threaded=true)\ntransform!(vol::AbstractArray{&lt;:Real,3}, output, v, z, temp; threaded=true)\ntransform!(img::AbstractGPUMatrix, output, v, z)\nIn-place squared Euclidean distance transforms. These functions apply the transform to the input data and store the result in the output argument.\n\nThe first function operates on vectors.\nThe second function operates on matrices with optional threading.\nThe third function operates on 3D arrays with optional threading.\nThe fourth function is specialized for GPU matrices.\n\nThe intermediate arrays v and z (and temp for 3D arrays) are used for computation. The threaded parameter enables parallel computation on the CPU.\n\nArguments\n\nf: Input vector, matrix, or 3D array.\noutput: Preallocated array to store the result.\nv: Preallocated array for indices, matching the dimensions of f.\nz: Preallocated array for intermediate values, one element larger than f.\ntemp: Preallocated array for intermediate values when transforming 3D arrays, matching the dimensions of output.\n\n\n\nExamples\nf = rand([0f0, 1f0], 10)\nf_bool = boolean_indicator(f)\noutput = similar(f)\nv = ones(Int32, size(f))\nz = ones(eltype(f), size(f) .+ 1)\ntransform!(f_bool, output, v, z)\n\n:::\n:::\n\n\n\n\n\n\n:::{#quarto-navigation-envelope .hidden}\n[Julia]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl\"}\n[Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXItdGl0bGU=\"}\n[User Guide]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1wcmV2\"}\n[Overview]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyOi9qdWxpYS9pbmRleC5odG1sT3ZlcnZpZXc=\"}\n[User Guide]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyOi9qdWxpYS9ndWlkZS5odG1sVXNlci1HdWlkZQ==\"}\n[API Reference]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1zaWRlYmFyOi9qdWxpYS9hcGkuaHRtbEFQSS1SZWZlcmVuY2U=\"}\n[Home]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6SG9tZQ==\"}\n[/index.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2luZGV4Lmh0bWw=\"}\n[Julia]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6SnVsaWE=\"}\n[Overview]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6T3ZlcnZpZXc=\"}\n[/julia/index.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2p1bGlhL2luZGV4Lmh0bWw=\"}\n[User Guide]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6VXNlciBHdWlkZQ==\"}\n[/julia/guide.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2p1bGlhL2d1aWRlLmh0bWw=\"}\n[API Reference]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6QVBJIFJlZmVyZW5jZQ==\"}\n[/julia/api.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2p1bGlhL2FwaS5odG1s\"}\n[Python]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6UHl0aG9u\"}\n[/python/index.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3B5dGhvbi9pbmRleC5odG1s\"}\n[/python/guide.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3B5dGhvbi9ndWlkZS5odG1s\"}\n[/python/api.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L3B5dGhvbi9hcGkuaHRtbA==\"}\n[About]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6QWJvdXQ=\"}\n[/about.html]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6L2Fib3V0Lmh0bWw=\"}\n[https://github.com/MolloiLab/DistanceTransforms.jl]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWludC1uYXZiYXI6aHR0cHM6Ly9naXRodWIuY29tL01vbGxvaUxhYi9EaXN0YW5jZVRyYW5zZm9ybXMuamw=\"}\n[API Reference]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLWJyZWFkY3J1bWJzLUFQSS1SZWZlcmVuY2U=\"}\n\n:::{.hidden .quarto-markdown-envelope-contents render-id=\"Zm9vdGVyLWxlZnQ=\"}\nCopyright 2024, Dale Black\n:::\n\n:::\n\n\n\n:::{#quarto-meta-markdown .hidden}\n[API Reference – Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW1ldGF0aXRsZQ==\"}\n[API Reference – Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU=\"}\n[API Reference – Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW9nY2FyZHRpdGxl\"}\n[Distance Transforms]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW1ldGFzaXRlbmFtZQ==\"}\n[Efficient distance transform operations for CPU and GPU in Julia and Python]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw==\"}\n[Efficient distance transform operations for CPU and GPU in Julia and Python]{.hidden .quarto-markdown-envelope-contents render-id=\"cXVhcnRvLW9nY2FyZGRkZXNj\"}\n:::\n\n\n\n\n&lt;!-- --&gt;\n\n::: {.quarto-embedded-source-code}\n```````````````````{.markdown shortcodes=\"false\"}\n---\ntitle: \"API Reference\"\nsidebar: julia\nformat:\n  html:\n    toc: true\n    cold-fold: true\nexecute:\n  engine: julia\n---\n\nThis page documents all the exported functions and types in DistanceTransforms.jl.\n\nquarto-executable-code-5450563D\n\n```julia\n#| echo: false\n\n\nusing DistanceTransforms\nusing Markdown\n\n\"\"\"\n    generate_markdown_docs()\n    \nGenerate Markdown documentation for all exported functions in DistanceTransforms.jl,\nreturning a single string with properly formatted markdown.\n\"\"\"\nfunction generate_markdown_docs()\n    # Get all exported names from DistanceTransforms\n    all_names = names(DistanceTransforms)\n    exported_functions = filter(x -&gt; x != :DistanceTransforms, all_names)\n    \n    # Create a string buffer to collect all output\n    result = IOBuffer()\n    \n    # Generate documentation for each function\n    for name in exported_functions\n        \n        # Get the documentation and convert it to string\n        doc = getproperty(DistanceTransforms, name)\n        doc_string = string(Docs.doc(doc))\n        \n        # Write the documentation\n        write(result, doc_string)\n        write(result, \"\\n\\n---\\n\\n\")\n    end\n    \n    # Return the collected documentation as a string\n    return String(take!(result))\nend\n\n# Call the function to generate the documentation\ndocs = generate_markdown_docs()\n\nprintln(docs)\n```````````````````",
    "crumbs": [
      "Home",
      "API Reference"
    ]
  },
  {
    "objectID": "julia/guide.html",
    "href": "julia/guide.html",
    "title": "User Guide",
    "section": "",
    "text": "This guide covers both basic and advanced usage of DistanceTransforms.jl.",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "julia/guide.html#getting-started",
    "href": "julia/guide.html#getting-started",
    "title": "User Guide",
    "section": "Getting Started",
    "text": "Getting Started\n\nInstallation\nusing Pkg\nPkg.add(\"DistanceTransforms\")\n\n\nBasic Usage\nThe primary function in DistanceTransforms.jl is transform. This function processes an array of 0s and 1s, converting each background element (0) into a value representing its squared Euclidean distance to the nearest foreground element (1).\n\nusing DistanceTransforms: transform, boolean_indicator\nusing CairoMakie: Figure, Axis, heatmap!, hidedecorations!\n\n# Create a random binary array\narr = rand([0, 1], 10, 10)\n\n# Apply distance transform\ntransformed = transform(boolean_indicator(arr))\n\n# Create visualization\nfig = Figure(size = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Original\")\nax2 = Axis(fig[1, 2], title = \"Distance Transform\")\nheatmap!(ax1, arr, colormap = :grays)\nheatmap!(ax2, transformed, colormap = :grays)\nfig\n\n\n\n\n\n\n\n\n\n\nReal-World Example\nLet’s apply a distance transform to a real image:\n\nusing Images\n\n# Download and load example image\nimg = load(download(\"http://docs.opencv.org/3.1.0/water_coins.jpg\"))\n\n# Convert to binary image\nimg_bw = Gray.(img) .&gt; 0.5\n\n# Apply distance transform\nimg_tfm = transform(boolean_indicator(img_bw))\n\n# Visualize\nfig = Figure(size = (900, 300))\nax1 = Axis(fig[1, 1], title = \"Original Image\")\nax2 = Axis(fig[1, 2], title = \"Segmented Image\")\nax3 = Axis(fig[1, 3], title = \"Distance Transform\")\nheatmap!(ax1, rotr90(img), colormap = :grays)\nheatmap!(ax2, rotr90(img_bw), colormap = :grays)\nheatmap!(ax3, rotr90(img_tfm), colormap = :grays)\nhidedecorations!.([ax1, ax2, ax3])\nfig\n\n\n\n\n\n\n\n\n\n\nUnderstanding Euclidean Distance\nThe library, by default, returns the squared Euclidean distance. If you need the true Euclidean distance, you can take the square root of each element:\n\n# Create sample binary array\narray2 = [\n    0 1 1 0 1\n    0 0 0 1 0\n    1 1 0 0 0\n]\n\n# Convert to boolean indicator\narray2_bool = boolean_indicator(array2)\n\n# Apply squared Euclidean distance transform\nsq_euc_transform = transform(array2_bool)\n\n# Convert to true Euclidean distance\neuc_transform = sqrt.(sq_euc_transform)\n\n# Display results\nprintln(\"Squared Euclidean Distance: $(sq_euc_transform)\")\nprintln(\"Euclidean Distance: $(euc_transform)\")\n\nSquared Euclidean Distance: Float32[1.0 0.0 0.0 1.0 0.0; 1.0 1.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0 2.0]\nEuclidean Distance: Float32[1.0 0.0 0.0 1.0 0.0; 1.0 1.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0 1.4142135]\n\n\n\n\nComparison with ImageMorphology.jl\n\nusing ImageMorphology: distance_transform, feature_transform\n\n# Apply ImageMorphology distance transform\neuc_transform2 = distance_transform(feature_transform(Bool.(array2)))\n\n# Compare results\nprintln(\"Are the results approximately equal?\")\nisapprox(euc_transform2, euc_transform; rtol = 1e-2)\n\nAre the results approximately equal?\n\n\ntrue",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "julia/guide.html#advanced-features",
    "href": "julia/guide.html#advanced-features",
    "title": "User Guide",
    "section": "Advanced Features",
    "text": "Advanced Features\n\nMulti-threading\nDistanceTransforms.jl efficiently utilizes multi-threading, particularly in its Felzenszwalb distance transform algorithm.\n⚠️ Julia might only load with 1 thread which makes the actual benchmark below meaningless and potentially confusing. Use this for understanding how to use the threaded kwarg ⚠️\n\nusing BenchmarkTools\nusing Base.Threads: nthreads\n\n# Create a random binary array\nx = boolean_indicator(rand([0, 1], 1000, 1000))\n\n# Single-threaded benchmark\nsingle_threaded = @benchmark transform($x; threaded = false)\n\n# Multi-threaded benchmark\nmulti_threaded = @benchmark transform($x; threaded = true)\n\n# Display results\nprintln(\"Number of threads: $(nthreads())\")\nprintln(\"Single-threaded minimum time: $(minimum(single_threaded).time / 1e6) ms\")\nprintln(\"Multi-threaded minimum time: $(minimum(multi_threaded).time / 1e6) ms\")\nprintln(\"Speedup factor: $(minimum(single_threaded).time / minimum(multi_threaded).time)\")\n\nNumber of threads: 1\nSingle-threaded minimum time: 17.508084 ms\nMulti-threaded minimum time: 17.558 ms\nSpeedup factor: 0.9971570793940084\n\n\n\n\nGPU Acceleration\nDistanceTransforms.jl extends its performance capabilities with GPU acceleration. The library uses Julia’s multiple dispatch to automatically leverage GPU resources when available.\n\nCUDA Example\nusing CUDA\nusing DistanceTransforms\n\n# Create a random array on GPU\nx_gpu = CUDA.rand([0, 1], 1000, 1000)\nx_gpu = boolean_indicator(x_gpu)\n\n# The transform function automatically uses GPU\nresult_gpu = transform(x_gpu)\n\n# Transfer result back to CPU if needed\nresult_cpu = Array(result_gpu)\n\n\nMetal Example\nusing Metal\nusing DistanceTransforms\n\n# Create a random array on GPU\nx_gpu = Metal.rand([0, 1], 1000, 1000)\nx_gpu = boolean_indicator(x_gpu)\n\n# The transform function automatically uses GPU\nresult_gpu = transform(x_gpu)\n\n# Transfer result back to CPU if needed\nresult_cpu = Array(result_gpu)\n\n\n\nPerformance Benchmarks\nPerformance comparison across different implementations for 2D and 3D distance transforms:\n\n\n\nPerformance Comparison\n\n\nAs shown in the graph, the GPU implementation demonstrates superior performance, especially for larger arrays.\n\n\nBest Practices\n\nFor small arrays (&lt;100x100): CPU with multi-threading is often sufficient\nFor medium arrays: Multi-threaded CPU may be faster than GPU due to lower overhead\nFor large arrays (&gt;1000x1000): GPU acceleration provides the best performance\nFor 3D data: GPU acceleration is strongly recommended due to the computational complexity",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "julia/guide.html#algorithm-details",
    "href": "julia/guide.html#algorithm-details",
    "title": "User Guide",
    "section": "Algorithm Details",
    "text": "Algorithm Details\nOn the CPU, DistanceTransforms.jl uses the squared Euclidean distance transform algorithm by Felzenszwalb and Huttenlocher, known for its accuracy and efficiency. On the GPU, thanks to the amazing AcceleratedKernels.jl and KernelAbstraction.jl packages, the algorithm is essentially identical.",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Distance Transforms",
    "section": "",
    "text": "DistanceTransforms.jl and distance_transforms provides efficient, GPU-accelerated, distance transform operations for arrays in both Julia and Python. Distance transforms are essential in computer vision, image processing, and machine learning tasks."
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "Distance Transforms",
    "section": "Features",
    "text": "Features\n\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\n🚀 High Performance\nOptimized algorithms for CPU and GPU\n\n\n🧵 Multi-threading\nParallel processing on CPU\n\n\n🖥️ GPU Acceleration\nSupport for NVIDIA (CUDA), AMD (ROCm), Apple (Metal), and Intel (oneAPI)\n\n\n🐍 Python Integration\nFull Python support via distance_transforms\n\n\n📏 Versatile Dimensions\nWorks with 1D, 2D, and 3D arrays\n\n\n📚 Well Documented\nComprehensive guides and examples"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Distance Transforms",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis project would not be possible without several excellent Julia packages:\n\nKernelAbstractions.jl: Provides hardware-agnostic GPU code that runs across different GPU platforms\nAcceleratedKernels.jl: Makes it dead simple to write GPU kernels with normal Julia code\nPythonCall.jl: Powers the Python interoperability layer for seamless integration\nDLPack.jl: Enables zero-copy tensor sharing with PyTorch for efficient GPU operations"
  },
  {
    "objectID": "index.html#why-this-library",
    "href": "index.html#why-this-library",
    "title": "Distance Transforms",
    "section": "Why This Library?",
    "text": "Why This Library?\n\n\n\n\n\n\n\n\n\n\nDistance Transforms\nImageMorphology.jl\nSciPy\n\n\n\n\nFast Distance Transform\n✅✅\n✅\n✅\n\n\nCPU Single-Threaded Support\n✅\n✅\n✅\n\n\nCPU Multi-Threaded Support\n✅\n✅\n❌\n\n\nNVIDIA/CUDA Support\n✅\n❌\n❌\n\n\nAMD/ROCM Support\n✅\n❌\n❌\n\n\nApple/Metal Support\n✅\n❌\n❌\n\n\nIntel/oneAPI Support\n✅\n❌\n❌\n\n\nPython Integration\n✅\n❌\n✅"
  },
  {
    "objectID": "index.html#choose-your-language",
    "href": "index.html#choose-your-language",
    "title": "Distance Transforms",
    "section": "Choose Your Language",
    "text": "Choose Your Language\n\n\n\nJulia\nusing DistanceTransforms\narr = rand([0, 1], 10, 10)\nresult = transform(boolean_indicator(arr))\nGet started with Julia →\n\n\n\nPython\nimport numpy as np\nimport distance_transforms as dts\narr = np.random.choice([0, 1], size=(10, 10)).astype(np.float32)\nresult = dts.transform(arr)\nGet started with Python →"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Distance Transforms",
    "section": "Installation",
    "text": "Installation\n\n\n\nJulia\nusing Pkg\nPkg.add(\"DistanceTransforms\")\n\n\n\nPython\npip install distance_transforms"
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Distance Transforms",
    "section": "Citation",
    "text": "Citation\nIf you use DistanceTransforms in your research, please cite:\n@software{DistanceTransforms,\n  author = {Black, Dale and Contributors},\n  title = {DistanceTransforms: Fast Distance Transforms for Julia and Python},\n  url = {https://github.com/MolloiLab/DistanceTransforms.jl},\n  year = {2023}\n}"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Distance Transforms",
    "section": "License",
    "text": "License\nDistanceTransforms is available under the MIT License."
  },
  {
    "objectID": "python/index.html",
    "href": "python/index.html",
    "title": "Overview",
    "section": "",
    "text": "distance_transforms is a high-performance Python package for computing distance transforms. It offers significant performance improvements over traditional implementations, especially for large arrays.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#installation",
    "href": "python/index.html#installation",
    "title": "Overview",
    "section": "Installation",
    "text": "Installation\nInstall distance_transforms using pip:\npip install distance_transforms",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#quick-example",
    "href": "python/index.html#quick-example",
    "title": "Overview",
    "section": "Quick Example",
    "text": "Quick Example\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport distance_transforms as dts\n\n# Create a random binary array\narr = np.random.choice([0, 1], size=(10, 10)).astype(np.float32)\n\n# Apply distance transform\nresult = dts.transform(arr)",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#what-is-a-distance-transform",
    "href": "python/index.html#what-is-a-distance-transform",
    "title": "Overview",
    "section": "What is a Distance Transform?",
    "text": "What is a Distance Transform?\nA distance transform converts a binary image into a grayscale image where the value of each pixel is the distance to the nearest foreground pixel (typically marked as 1 in the binary image). This transformation is useful in various applications including:\n\nPath planning and navigation\nMorphological operations\nFeature extraction\nMedical image analysis\nComputer vision algorithms",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#key-features",
    "href": "python/index.html#key-features",
    "title": "Overview",
    "section": "Key Features",
    "text": "Key Features\n\nHigh Performance: Optimized algorithms for CPU and GPU\nJulia Integration: Powered by DistanceTransforms.jl for maximum efficiency\nGPU Acceleration: Support for NVIDIA GPUs through PyTorch and CUDA\nSimple API: Clean, intuitive Python interface\nNumPy Integration: Works seamlessly with NumPy arrays\nPyTorch Support: Native support for PyTorch CUDA tensors\nMulti-Dimensional: Works with 1D, 2D, and 3D arrays",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#performance-comparison",
    "href": "python/index.html#performance-comparison",
    "title": "Overview",
    "section": "Performance Comparison",
    "text": "Performance Comparison\ndistance_transforms significantly outperforms traditional implementations:\nimport numpy as np\nimport torch\nimport time\nimport distance_transforms as dts\nfrom scipy.ndimage import distance_transform_edt\n\n# Create a large 3D array\nsize = (100, 100, 100)\narr = np.random.choice([0, 1], size=size).astype(np.float32)\n\n# Benchmark SciPy\nstart = time.time()\nscipy_result = distance_transform_edt(arr == 0) ** 2\nprint(f\"SciPy time: {time.time() - start:.3f}s\")\n\n# Benchmark distance_transforms (CPU)\nstart = time.time()\ndts_result = dts.transform(arr)\nprint(f\"distance_transforms CPU time: {time.time() - start:.3f}s\")\n\n# Benchmark distance_transforms (GPU)\nif torch.cuda.is_available():\n    tensor = torch.tensor(arr, device='cuda')\n    start = time.time()\n    dts_gpu_result = dts.transform_cuda(tensor)\n    print(f\"distance_transforms GPU time: {time.time() - start:.3f}s\")\nTypical results on modern hardware: - SciPy: ~1.200s - distance_transforms (CPU): ~0.500s - distance_transforms (GPU): ~0.120s",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#api-preview",
    "href": "python/index.html#api-preview",
    "title": "Overview",
    "section": "API Preview",
    "text": "API Preview\n# CPU transform with NumPy\nimport numpy as np\nimport distance_transforms as dts\narr = np.random.choice([0, 1], size=(100, 100)).astype(np.float32)\nresult = dts.transform(arr)\n\n# GPU transform with PyTorch\nimport torch\nimport distance_transforms as dts\ntensor = torch.rand((100, 100), device='cuda')\ntensor = (tensor &gt; 0.5).float()\nresult = dts.transform_cuda(tensor)",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#when-to-use-distance-transforms",
    "href": "python/index.html#when-to-use-distance-transforms",
    "title": "Overview",
    "section": "When to Use Distance Transforms",
    "text": "When to Use Distance Transforms\nDistance transforms are particularly useful in:\n\nMedical Image Analysis: Segment organs, measure distances between anatomical structures\nComputer Vision: Object recognition, shape analysis, skeletonization\nPath Planning: Navigation algorithms in robotics\nDeep Learning: Custom loss functions like Hausdorff distance for segmentation tasks",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/index.html#next-steps",
    "href": "python/index.html#next-steps",
    "title": "Overview",
    "section": "Next Steps",
    "text": "Next Steps\n\nExplore the User Guide for comprehensive documentation\nCheck the API Reference for detailed function information\nVisit our GitHub repository for the latest updates",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "python/guide.html",
    "href": "python/guide.html",
    "title": "User Guide",
    "section": "",
    "text": "This guide covers both basic and advanced usage of the distance_transforms library.",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#getting-started",
    "href": "python/guide.html#getting-started",
    "title": "User Guide",
    "section": "Getting Started",
    "text": "Getting Started\n\nInstallation\npip install distance_transforms\nFor GPU support, make sure you have PyTorch with CUDA installed.\n\n\nBasic Usage\nThe primary function in distance_transforms is transform. This function takes a binary array (with 0s and 1s) and calculates the squared Euclidean distance from each 0 pixel to the nearest 1 pixel.\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport distance_transforms as dts\n\n# Create a random binary array\narr = np.random.choice([0, 1], size=(10, 10)).astype(np.float32)\n\n# Apply distance transform\nresult = dts.transform(arr)\n\n# Visualize\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))\nax1.imshow(arr, cmap='gray')\nax1.set_title('Original')\nax2.imshow(result, cmap='gray')\nax2.set_title('Distance Transform')\nplt.tight_layout()\nplt.show()\n\n\nReal-World Example\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport distance_transforms as dts\nfrom skimage import io, color, filters\n\n# Load image and process\nimg = io.imread(\"sample.jpg\")\nimg_gray = color.rgb2gray(img)\nimg_binary = img_gray &gt; filters.threshold_otsu(img_gray)\nimg_dist = dts.transform(img_binary.astype(np.float32))\n\n# Visualize\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\naxes[0].imshow(img)\naxes[0].set_title('Original Image')\naxes[1].imshow(img_binary, cmap='gray')\naxes[1].set_title('Binary Image')\naxes[2].imshow(img_dist, cmap='viridis')\naxes[2].set_title('Distance Transform')\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#advanced-features",
    "href": "python/guide.html#advanced-features",
    "title": "User Guide",
    "section": "Advanced Features",
    "text": "Advanced Features\n\nGPU Acceleration\ndistance_transforms provides a specific function for GPU acceleration using PyTorch tensors: transform_cuda.\nimport torch\nimport distance_transforms as dts\n\n# Create a tensor on GPU\nx_gpu = torch.rand((100, 100), device='cuda')\nx_gpu = (x_gpu &gt; 0.5).float()  # Convert to binary (0s and 1s)\n\n# Apply transform on GPU\nresult_gpu = dts.transform_cuda(x_gpu)\n\n\nWorking with 3D Data\nBoth transform and transform_cuda support 3D arrays as well:\nimport numpy as np\nimport distance_transforms as dts\n\n# Create a 3D binary array\narr_3d = np.zeros((20, 20, 20), dtype=np.float32)\narr_3d[5, 5, 5] = 1\narr_3d[15, 15, 15] = 1\n\n# Apply distance transform\nresult_3d = dts.transform(arr_3d)",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#performance-benchmarks",
    "href": "python/guide.html#performance-benchmarks",
    "title": "User Guide",
    "section": "Performance Benchmarks",
    "text": "Performance Benchmarks\ndistance_transforms generally outperforms other Python implementations, especially for large arrays and when using GPU acceleration:\n\n\n\nImplementation\n100×100\n1000×1000\n100×100×100\n\n\n\n\nSciPy\n2.5 ms\n250 ms\n1200 ms\n\n\ndistance_transforms (CPU)\n1.2 ms\n120 ms\n500 ms\n\n\ndistance_transforms (GPU)\n0.8 ms\n25 ms\n120 ms\n\n\n\nTimes are approximate and may vary based on hardware.\n\nBenchmarking Code Example\nYou can benchmark the performance yourself:\nimport numpy as np\nimport torch\nimport time\nimport distance_transforms as dts\nfrom scipy.ndimage import distance_transform_edt\n\n# Create test data\nsize = (224, 224)\narr = np.random.choice([0, 1], size=size).astype(np.float32)\ntensor = torch.tensor(arr, device='cuda')\n\n# Benchmark distance_transforms (CPU)\nstart = time.time()\nresult_cpu = dts.transform(arr)\ncpu_time = time.time() - start\n\n# Benchmark distance_transforms (GPU)\nstart = time.time()\nresult_gpu = dts.transform_cuda(tensor)\ngpu_time = time.time() - start\n\n# Benchmark SciPy\nstart = time.time()\nresult_scipy = distance_transform_edt(arr == 0) ** 2\nscipy_time = time.time() - start\n\nprint(f\"CPU time: {cpu_time:.4f}s\")\nprint(f\"GPU time: {gpu_time:.4f}s\")\nprint(f\"SciPy time: {scipy_time:.4f}s\")\nprint(f\"GPU speedup vs. CPU: {cpu_time/gpu_time:.1f}x\")\nprint(f\"GPU speedup vs. SciPy: {scipy_time/gpu_time:.1f}x\")",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#integration-with-deep-learning",
    "href": "python/guide.html#integration-with-deep-learning",
    "title": "User Guide",
    "section": "Integration with Deep Learning",
    "text": "Integration with Deep Learning\ndistance_transforms can be integrated with deep learning workflows, particularly for tasks like computing Hausdorff distance loss:\nimport torch\nimport torch.nn.functional as F\nimport distance_transforms as dts\n\ndef hausdorff_loss(pred, target):\n    # Convert predictions to binary\n    pred_binary = (pred &gt; 0.5).float()\n    \n    # Calculate distance transforms\n    pred_dt = dts.transform_cuda(pred_binary)\n    target_dt = dts.transform_cuda(target)\n    \n    # Compute Hausdorff distances\n    d_pt = torch.mean(target * pred_dt)\n    d_tp = torch.mean(pred_binary * target_dt)\n    \n    return d_pt + d_tp\n\nExample in a PyTorch Training Loop\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport distance_transforms as dts\n\n# Define a simple model\nmodel = nn.Sequential(\n    nn.Conv2d(1, 16, 3, padding=1),\n    nn.ReLU(),\n    nn.Conv2d(16, 1, 3, padding=1),\n    nn.Sigmoid()\n)\n\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# Training loop with Hausdorff loss\ndef train(model, dataloader, epochs=10):\n    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    model.to(device)\n    \n    for epoch in range(epochs):\n        for inputs, targets in dataloader:\n            inputs, targets = inputs.to(device), targets.to(device)\n            \n            # Forward pass\n            outputs = model(inputs)\n            \n            # Calculate loss\n            dice_loss = F.binary_cross_entropy(outputs, targets)\n            \n            # Add Hausdorff distance loss\n            outputs_binary = (outputs &gt; 0.5).float()\n            targets_binary = (targets &gt; 0.5).float()\n            \n            pred_dt = dts.transform_cuda(outputs_binary)\n            target_dt = dts.transform_cuda(targets_binary)\n            \n            hausdorff = torch.mean(targets_binary * pred_dt) + torch.mean(outputs_binary * target_dt)\n            \n            # Combine losses\n            loss = dice_loss + 0.5 * hausdorff\n            \n            # Backward pass and optimize\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n            \n        print(f\"Epoch {epoch+1}, Loss: {loss.item():.4f}\")",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#first-time-import-note",
    "href": "python/guide.html#first-time-import-note",
    "title": "User Guide",
    "section": "First-Time Import Note",
    "text": "First-Time Import Note\nThe first time you import distance_transforms, it may take a while (up to 8 minutes) as it sets up the Julia environment and precompiles the necessary Julia packages. Subsequent imports will be much faster.\n# First import may be slow\nimport distance_transforms as dts  # May take up to 8 minutes\n\n# Create a small test array to verify everything works\nimport numpy as np\ntest_arr = np.random.choice([0, 1], size=(5, 5)).astype(np.float32)\nresult = dts.transform(test_arr)\nprint(result)",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#implementation-details",
    "href": "python/guide.html#implementation-details",
    "title": "User Guide",
    "section": "Implementation Details",
    "text": "Implementation Details\n\nHow it Works\ndistance_transforms is a Python wrapper around the Julia package DistanceTransforms.jl. The package uses the following approach:\n\nFor CPU operations:\n\nTakes a NumPy array and converts it to a Julia array\nApplies the boolean indicator function to prepare the data\nComputes the distance transform in Julia\nConverts the result back to a NumPy array\n\nFor GPU operations:\n\nTakes a PyTorch CUDA tensor and shares it with Julia using DLPack (no copying)\nApplies the boolean indicator function in Julia\nComputes the distance transform in Julia using GPU acceleration\nShares the result back to PyTorch using DLPack",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/guide.html#next-steps",
    "href": "python/guide.html#next-steps",
    "title": "User Guide",
    "section": "Next Steps",
    "text": "Next Steps\nFor detailed API information and function signatures, refer to the API Reference.",
    "crumbs": [
      "Home",
      "User Guide"
    ]
  },
  {
    "objectID": "python/api.html",
    "href": "python/api.html",
    "title": "API Reference",
    "section": "",
    "text": "This page documents all the exported functions in the distance_transforms Python package.",
    "crumbs": [
      "Home",
      "API Reference"
    ]
  },
  {
    "objectID": "python/api.html#core-functions",
    "href": "python/api.html#core-functions",
    "title": "API Reference",
    "section": "Core Functions",
    "text": "Core Functions\n\ntransform\nimport distance_transforms as dts\n\nresult = dts.transform(arr)\nComputes the squared Euclidean distance transform of a binary array using NumPy arrays.\n\nParameters\n\narr: A NumPy array containing binary values (0s and 1s)\n\nCan be 1D, 2D, or 3D\nMust be a NumPy array type\n\n\n\n\nReturns\n\nA NumPy array containing the squared Euclidean distance from each 0 pixel to the nearest 1 pixel\nThe output has the same shape and type as the input array\n\n\n\nExamples\nimport numpy as np\nimport distance_transforms as dts\n\n# Basic usage with NumPy\narr = np.random.choice([0, 1], size=(10, 10)).astype(np.float32)\nresult = dts.transform(arr)\n\n\n\ntransform_cuda\nimport distance_transforms as dts\nimport torch\n\nresult = dts.transform_cuda(tensor)\nComputes the squared Euclidean distance transform of a binary array using PyTorch tensors on CUDA.\n\nParameters\n\ntensor: A PyTorch tensor containing binary values (0s and 1s)\n\nMust be a CUDA tensor (on GPU)\nCan be 1D, 2D, or 3D\n\n\n\n\nReturns\n\nA PyTorch tensor containing the squared Euclidean distance from each 0 pixel to the nearest 1 pixel\nThe output has the same shape, type, and device as the input tensor\n\n\n\nExamples\nimport torch\nimport distance_transforms as dts\n\n# Create a tensor on GPU\ntensor = torch.rand((100, 100), device='cuda')\ntensor = (tensor &gt; 0.5).float()\n\n# Apply transform on GPU\nresult = dts.transform_cuda(tensor)",
    "crumbs": [
      "Home",
      "API Reference"
    ]
  },
  {
    "objectID": "python/api.html#implementation-details",
    "href": "python/api.html#implementation-details",
    "title": "API Reference",
    "section": "Implementation Details",
    "text": "Implementation Details\n\nCPU Implementation\nWhen running on CPU with transform(), distance_transforms wraps the Julia implementation from DistanceTransforms.jl:\n\nThe NumPy array is converted to a Julia array\nThe binary indicator function is applied to prepare the data\nThe distance transform is computed in Julia\nThe result is converted back to a NumPy array with the same dtype as the input\n\n\n\nGPU Implementation\nWhen using transform_cuda() with CUDA tensors:\n\nThe PyTorch tensor is shared with Julia using DLPack without copying\nThe computation is performed using Julia’s GPU optimizations\nThe result is shared back to PyTorch using DLPack\n\n\n\nPerformance Considerations\n\nGPU acceleration works best for large arrays (typically 128×128 or larger)\nThe first call to either function may be slower due to Julia’s JIT compilation",
    "crumbs": [
      "Home",
      "API Reference"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "DistanceTransforms is a high-performance library for computing distance transforms, available for both Julia and Python. The library provides efficient, GPU-accelerated distance transform operations with a simple API.\n\n\n\nHigh Performance: Optimized for CPU and GPU\nMulti-platform: Julia package with Python bindings\nGPU Support: NVIDIA (CUDA), AMD (ROCm), and Apple (Metal)\nVersatile: Works with 1D, 2D, and 3D arrays\nSimple API: Clean, intuitive interfaces in both languages\n\n\n\n\nDistance transforms have numerous applications across different fields:\n\nMedical Imaging: Organ segmentation, distance metrics between structures\nComputer Vision: Object recognition, shape analysis, feature extraction\nPath Planning: Navigation algorithms in robotics\nDeep Learning: Custom loss functions like Hausdorff distance\n\n\n\n\nThe core algorithm is based on the Felzenszwalb method, providing O(n) time complexity. For GPU acceleration, the library uses KernelAbstractions.jl, allowing hardware-agnostic implementation across different GPU architectures.\nThe Python wrapper (distance_transforms) provides seamless integration with NumPy and PyTorch, enabling Python users to leverage the high-performance Julia implementation.\n\n\n\nThis project would not be possible without several excellent Julia packages:\n\nKernelAbstractions.jl: Provides hardware-agnostic GPU code that runs across different GPU platforms\nAcceleratedKernels.jl: Makes it dead simple to write GPU kernels with normal Julia code\nPythonCall.jl: Powers the Python interoperability layer for seamless integration\nDLPack.jl: Enables zero-copy tensor sharing with PyTorch for efficient GPU operations\n\nWe are grateful to the developers of these packages and the broader Julia and Python communities for their ongoing support and contributions.\n\n\n\nIf you use DistanceTransforms in your research, please cite:\n@software{DistanceTransforms,\n  author = {Black, Dale and Contributors},\n  title = {DistanceTransforms: Fast Distance Transforms for Julia and Python},\n  url = {https://github.com/MolloiLab/DistanceTransforms.jl},\n  year = {2023}\n}\n\n\n\nDistanceTransforms is available under the MIT License.\n\n\n\n\nDistanceTransforms.jl (Julia)\ndistance_transforms (Python)"
  },
  {
    "objectID": "about.html#features",
    "href": "about.html#features",
    "title": "About",
    "section": "",
    "text": "High Performance: Optimized for CPU and GPU\nMulti-platform: Julia package with Python bindings\nGPU Support: NVIDIA (CUDA), AMD (ROCm), and Apple (Metal)\nVersatile: Works with 1D, 2D, and 3D arrays\nSimple API: Clean, intuitive interfaces in both languages"
  },
  {
    "objectID": "about.html#applications",
    "href": "about.html#applications",
    "title": "About",
    "section": "",
    "text": "Distance transforms have numerous applications across different fields:\n\nMedical Imaging: Organ segmentation, distance metrics between structures\nComputer Vision: Object recognition, shape analysis, feature extraction\nPath Planning: Navigation algorithms in robotics\nDeep Learning: Custom loss functions like Hausdorff distance"
  },
  {
    "objectID": "about.html#implementation",
    "href": "about.html#implementation",
    "title": "About",
    "section": "",
    "text": "The core algorithm is based on the Felzenszwalb method, providing O(n) time complexity. For GPU acceleration, the library uses KernelAbstractions.jl, allowing hardware-agnostic implementation across different GPU architectures.\nThe Python wrapper (distance_transforms) provides seamless integration with NumPy and PyTorch, enabling Python users to leverage the high-performance Julia implementation."
  },
  {
    "objectID": "about.html#acknowledgements",
    "href": "about.html#acknowledgements",
    "title": "About",
    "section": "",
    "text": "This project would not be possible without several excellent Julia packages:\n\nKernelAbstractions.jl: Provides hardware-agnostic GPU code that runs across different GPU platforms\nAcceleratedKernels.jl: Makes it dead simple to write GPU kernels with normal Julia code\nPythonCall.jl: Powers the Python interoperability layer for seamless integration\nDLPack.jl: Enables zero-copy tensor sharing with PyTorch for efficient GPU operations\n\nWe are grateful to the developers of these packages and the broader Julia and Python communities for their ongoing support and contributions."
  },
  {
    "objectID": "about.html#citation",
    "href": "about.html#citation",
    "title": "About",
    "section": "",
    "text": "If you use DistanceTransforms in your research, please cite:\n@software{DistanceTransforms,\n  author = {Black, Dale and Contributors},\n  title = {DistanceTransforms: Fast Distance Transforms for Julia and Python},\n  url = {https://github.com/MolloiLab/DistanceTransforms.jl},\n  year = {2023}\n}"
  },
  {
    "objectID": "about.html#license",
    "href": "about.html#license",
    "title": "About",
    "section": "",
    "text": "DistanceTransforms is available under the MIT License."
  },
  {
    "objectID": "about.html#links",
    "href": "about.html#links",
    "title": "About",
    "section": "",
    "text": "DistanceTransforms.jl (Julia)\ndistance_transforms (Python)"
  },
  {
    "objectID": "julia/index.html",
    "href": "julia/index.html",
    "title": "Overview",
    "section": "",
    "text": "DistanceTransforms.jl is a high-performance Julia package for computing distance transforms. It offers significant performance improvements over traditional implementations, especially for large arrays.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "julia/index.html#installation",
    "href": "julia/index.html#installation",
    "title": "Overview",
    "section": "Installation",
    "text": "Installation\nInstall DistanceTransforms.jl using Julia’s package manager:\nusing Pkg\nPkg.add(\"DistanceTransforms\")",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "julia/index.html#quick-example",
    "href": "julia/index.html#quick-example",
    "title": "Overview",
    "section": "Quick Example",
    "text": "Quick Example\n\nusing DistanceTransforms: transform, boolean_indicator\nusing CairoMakie: Figure, Axis, heatmap!\n\n# Create a sample binary array\narr = rand([0, 1], 10, 10)\n\n# Apply distance transform\nresult = transform(boolean_indicator(arr))\n\n# Visualize\nfig = Figure(size = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Original\")\nax2 = Axis(fig[1, 2], title = \"Distance Transform\")\nheatmap!(ax1, arr, colormap = :grays)\nheatmap!(ax2, result, colormap = :grays)\nfig",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "julia/index.html#key-features",
    "href": "julia/index.html#key-features",
    "title": "Overview",
    "section": "Key Features",
    "text": "Key Features\n\nFast Distance Transform: Employs the efficient Felzenszwalb algorithm\nMulti-threading: Parallelized computation on CPU\nGPU Support:\n\nNVIDIA (CUDA)\nAMD (ROCm)\nApple (Metal)\nIntel (oneAPI)\n\nFlexible Input: Works with arrays of various dimensions (1D, 2D, 3D)",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "julia/index.html#next-steps",
    "href": "julia/index.html#next-steps",
    "title": "Overview",
    "section": "Next Steps",
    "text": "Next Steps\n\nExplore the User Guide for comprehensive documentation\nCheck the API Reference for detailed function information",
    "crumbs": [
      "Home",
      "Overview"
    ]
  }
]